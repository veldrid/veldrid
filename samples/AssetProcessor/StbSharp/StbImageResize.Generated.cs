// Generated by Sichem at 1/28/2018 1:06:16 PM

using System;
using System.Runtime.InteropServices;

namespace StbSharp
{
	unsafe partial class StbImageResize
	{
		[StructLayout(LayoutKind.Sequential)]
		public struct stbir__contributors
		{
			public int n0;
			public int n1;
		}

		public const int STBIR_EDGE_CLAMP = 1;
		public const int STBIR_EDGE_REFLECT = 2;
		public const int STBIR_EDGE_WRAP = 3;
		public const int STBIR_EDGE_ZERO = 4;
		public const int STBIR_FILTER_DEFAULT = 0;
		public const int STBIR_FILTER_BOX = 1;
		public const int STBIR_FILTER_TRIANGLE = 2;
		public const int STBIR_FILTER_CUBICBSPLINE = 3;
		public const int STBIR_FILTER_CATMULLROM = 4;
		public const int STBIR_FILTER_MITCHELL = 5;
		public const int STBIR_COLORSPACE_LINEAR = 0;
		public const int STBIR_COLORSPACE_SRGB = 1;
		public const int STBIR_MAX_COLORSPACES = 2;
		public const int STBIR_TYPE_UINT8 = 0;
		public const int STBIR_TYPE_UINT16 = 1;
		public const int STBIR_TYPE_UINT32 = 2;
		public const int STBIR_TYPE_FLOAT = 3;
		public const int STBIR_MAX_TYPES = 4;
		public static byte[] stbir__type_size = { 1, 2, 4, 4 };

		public static float[] stbir__srgb_uchar_to_linear_float =
		{
			0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f,
			0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f, 0.003347f, 0.003677f, 0.004025f,
			0.004391f,
			0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f, 0.008023f, 0.008568f,
			0.009134f,
			0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f, 0.015209f,
			0.015996f,
			0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f,
			0.025187f,
			0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f,
			0.036889f,
			0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f,
			0.051269f,
			0.052861f, 0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f,
			0.068478f,
			0.070360f, 0.072272f, 0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f,
			0.088656f,
			0.090842f, 0.093059f, 0.095307f, 0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f,
			0.111932f,
			0.114435f, 0.116971f, 0.119538f, 0.122139f, 0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f,
			0.138432f,
			0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f, 0.155926f, 0.158961f, 0.162029f, 0.165132f,
			0.168269f,
			0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f, 0.191202f, 0.194618f, 0.198069f,
			0.201556f,
			0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f, 0.230740f, 0.234551f,
			0.238398f,
			0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f, 0.274677f,
			0.278894f,
			0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f,
			0.323143f,
			0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f,
			0.371238f,
			0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f,
			0.423268f,
			0.428691f, 0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f,
			0.479320f,
			0.485150f, 0.491021f, 0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f,
			0.539480f,
			0.545725f, 0.552011f, 0.558340f, 0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f,
			0.603827f,
			0.610496f, 0.617207f, 0.623960f, 0.630757f, 0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f,
			0.672443f,
			0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f, 0.715694f, 0.723055f, 0.730461f, 0.737911f,
			0.745404f,
			0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f, 0.799103f, 0.806952f, 0.814847f,
			0.822786f,
			0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f, 0.887923f, 0.896269f,
			0.904661f,
			0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f, 0.982251f,
			0.991102f, 1.0f
		};

		public static uint[] fp32_to_srgb8_tab4 =
		{
			0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d,
			0x009a000d, 0x00a1000d, 0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a,
			0x0101001a, 0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,
			0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067, 0x037800ce,
			0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5, 0x06970158, 0x07420142,
			0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2, 0x0b0f01cb, 0x0bf401ae, 0x0ccb0195,
			0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143, 0x11070264, 0x1238023e, 0x1357021d, 0x14660201,
			0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af, 0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d,
			0x201a0270, 0x21520256, 0x227d0240, 0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341,
			0x2ebe031f, 0x304d0300, 0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a,
			0x42bd0401, 0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,
			0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723
		};

		public static int stbir__min(int a, int b)
		{
			return (int)((a) < (b) ? a : b);
		}

		public static int stbir__max(int a, int b)
		{
			return (int)((a) > (b) ? a : b);
		}

		public static float stbir__saturate(float x)
		{
			if ((x) < (0))
				return (float)(0);
			if ((x) > (1))
				return (float)(1);
			return (float)(x);
		}

		public static float stbir__srgb_to_linear(float f)
		{
			if (f <= 0.04045f)
				return (float)(f / 12.92f);
			else
				return (float)(CRuntime.pow((double)((f + 0.055f) / 1.055f), (double)(2.4f)));
		}

		public static float stbir__linear_to_srgb(float f)
		{
			if (f <= 0.0031308f)
				return (float)(f * 12.92f);
			else
				return (float)(1.055f * (float)(CRuntime.pow((double)(f), (double)(1 / 2.4f))) - 0.055f);
		}

		public static float stbir__filter_trapezoid(float x, float scale)
		{
			float halfscale = (float)(scale / 2);
			float t = (float)(0.5f + halfscale);
			x = ((float)(CRuntime.fabs((double)(x))));
			if ((x) >= (t))
				return (float)(0);
			else
			{
				float r = (float)(0.5f - halfscale);
				if (x <= r)
					return (float)(1);
				else
					return (float)((t - x) / scale);
			}

		}

		public static float stbir__support_trapezoid(float scale)
		{
			return (float)(0.5f + scale / 2);
		}

		public static float stbir__filter_triangle(float x, float s)
		{
			x = ((float)(CRuntime.fabs((double)(x))));
			if (x <= 1.0f)
				return (float)(1 - x);
			else
				return (float)(0);
		}

		public static float stbir__filter_cubic(float x, float s)
		{
			x = ((float)(CRuntime.fabs((double)(x))));
			if ((x) < (1.0f))
				return (float)((4 + x * x * (3 * x - 6)) / 6);
			else if ((x) < (2.0f))
				return (float)((8 + x * (-12 + x * (6 - x))) / 6);
			return (float)(0.0f);
		}

		public static float stbir__filter_catmullrom(float x, float s)
		{
			x = ((float)(CRuntime.fabs((double)(x))));
			if ((x) < (1.0f))
				return (float)(1 - x * x * (2.5f - 1.5f * x));
			else if ((x) < (2.0f))
				return (float)(2 - x * (4 + x * (0.5f * x - 2.5f)));
			return (float)(0.0f);
		}

		public static float stbir__filter_mitchell(float x, float s)
		{
			x = ((float)(CRuntime.fabs((double)(x))));
			if ((x) < (1.0f))
				return (float)((16 + x * x * (21 * x - 36)) / 18);
			else if ((x) < (2.0f))
				return (float)((32 + x * (-60 + x * (36 - 7 * x))) / 18);
			return (float)(0.0f);
		}

		public static float stbir__support_zero(float s)
		{
			return (float)(0);
		}

		public static float stbir__support_one(float s)
		{
			return (float)(1);
		}

		public static float stbir__support_two(float s)
		{
			return (float)(2);
		}

		public static int stbir__use_upsampling(float ratio)
		{
			return (int)((ratio) > (1) ? 1 : 0);
		}

		public static int stbir__use_width_upsampling(stbir__info stbir_info)
		{
			return (int)(stbir__use_upsampling((float)(stbir_info.horizontal_scale)));
		}

		public static int stbir__use_height_upsampling(stbir__info stbir_info)
		{
			return (int)(stbir__use_upsampling((float)(stbir_info.vertical_scale)));
		}

		public static int stbir__get_filter_pixel_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float)(scale))) != 0)
				return (int)(CRuntime.ceil(
					(double)(stbir__filter_info_table[filter].support((float)(1 / scale)) * 2)));
			else
				return (int)(CRuntime.ceil(
					(double)(stbir__filter_info_table[filter].support((float)(scale)) * 2 / scale)));
		}

		public static int stbir__get_filter_pixel_margin(int filter, float scale)
		{
			return (int)(stbir__get_filter_pixel_width((int)(filter), (float)(scale)) / 2);
		}

		public static int stbir__get_coefficient_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float)(scale))) != 0)
				return (int)(CRuntime.ceil(
					(double)(stbir__filter_info_table[filter].support((float)(1 / scale)) * 2)));
			else
				return (int)(CRuntime.ceil((double)(stbir__filter_info_table[filter].support((float)(scale)) * 2)));
		}

		public static int stbir__get_contributors(float scale, int filter, int input_size, int output_size)
		{
			if ((stbir__use_upsampling((float)(scale))) != 0)
				return (int)(output_size);
			else
				return (int)(input_size + stbir__get_filter_pixel_margin((int)(filter), (float)(scale)) * 2);
		}

		public static int stbir__get_total_horizontal_coefficients(stbir__info info)
		{
			return
				(int)
				(info.horizontal_num_contributors *
				 stbir__get_coefficient_width((int)(info.horizontal_filter), (float)(info.horizontal_scale)));
		}

		public static int stbir__get_total_vertical_coefficients(stbir__info info)
		{
			return
				(int)
				(info.vertical_num_contributors *
				 stbir__get_coefficient_width((int)(info.vertical_filter), (float)(info.vertical_scale)));
		}

		public static stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)
		{
			return &contributors[n];
		}

		public static float* stbir__get_coefficient(float* coefficients, int filter, float scale, int n, int c)
		{
			int width = (int)(stbir__get_coefficient_width((int)(filter), (float)(scale)));
			return &coefficients[width * n + c];
		}

		public static int stbir__edge_wrap_slow(int edge, int n, int max)
		{
			switch (edge)
			{
				case STBIR_EDGE_ZERO:
					return (int)(0);
				case STBIR_EDGE_CLAMP:
					if ((n) < (0))
						return (int)(0);
					if ((n) >= (max))
						return (int)(max - 1);
					return (int)(n);
				case STBIR_EDGE_REFLECT:
				{
					if ((n) < (0))
					{
						if ((n) < (max))
							return (int)(-n);
						else
							return (int)(max - 1);
					}

					if ((n) >= (max))
					{
						int max2 = (int)(max * 2);
						if ((n) >= (max2))
							return (int)(0);
						else
							return (int)(max2 - n - 1);
					}

					return (int)(n);
				}
				case STBIR_EDGE_WRAP:
					if ((n) >= (0))
						return (int)(n % max);
					else
					{
						int m = (int)((-n) % max);
						if (m != 0)
							m = (int)(max - m);
						return (int)(m);
					}

					return (int)(n);
				default:
					;
					return (int)(0);
			}

		}

		public static int stbir__edge_wrap(int edge, int n, int max)
		{
			if (((n) >= (0)) && ((n) < (max)))
				return (int)(n);
			return (int)(stbir__edge_wrap_slow((int)(edge), (int)(n), (int)(max)));
		}

		public static void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio,
			float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)
		{
			float out_pixel_center = (float)((float)(n) + 0.5f);
			float out_pixel_influence_lowerbound = (float)(out_pixel_center - out_filter_radius);
			float out_pixel_influence_upperbound = (float)(out_pixel_center + out_filter_radius);
			float in_pixel_influence_lowerbound = (float)((out_pixel_influence_lowerbound + out_shift) / scale_ratio);
			float in_pixel_influence_upperbound = (float)((out_pixel_influence_upperbound + out_shift) / scale_ratio);
			*in_center_of_out = (float)((out_pixel_center + out_shift) / scale_ratio);
			*in_first_pixel = ((int)(CRuntime.floor((double)(in_pixel_influence_lowerbound + 0.5))));
			*in_last_pixel = ((int)(CRuntime.floor((double)(in_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio,
			float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)
		{
			float in_pixel_center = (float)((float)(n) + 0.5f);
			float in_pixel_influence_lowerbound = (float)(in_pixel_center - in_pixels_radius);
			float in_pixel_influence_upperbound = (float)(in_pixel_center + in_pixels_radius);
			float out_pixel_influence_lowerbound = (float)(in_pixel_influence_lowerbound * scale_ratio - out_shift);
			float out_pixel_influence_upperbound = (float)(in_pixel_influence_upperbound * scale_ratio - out_shift);
			*out_center_of_in = (float)(in_pixel_center * scale_ratio - out_shift);
			*out_first_pixel = ((int)(CRuntime.floor((double)(out_pixel_influence_lowerbound + 0.5))));
			*out_last_pixel = ((int)(CRuntime.floor((double)(out_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_coefficients_upsample(stbir__info stbir_info, int filter, float scale,
			int in_first_pixel, int in_last_pixel, float in_center_of_out, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			float total_filter = (float)(0);
			float filter_scale;
			contributor->n0 = (int)(in_first_pixel);
			contributor->n1 = (int)(in_last_pixel);
			for (i = (int)(0); i <= in_last_pixel - in_first_pixel; i++)
			{
				float in_pixel_center = (float)((float)(i + in_first_pixel) + 0.5f);
				coefficient_group[i] =
					(float)(stbir__filter_info_table[filter]
						.kernel((float)(in_center_of_out - in_pixel_center), (float)(1 / scale)));
				if (((i) == (0)) && (coefficient_group[i] == 0))
				{
					contributor->n0 = (int)(++in_first_pixel);
					i--;
					continue;
				}

				total_filter += (float)(coefficient_group[i]);
			}

			filter_scale = (float)(1 / total_filter);
			for (i = (int)(0); i <= in_last_pixel - in_first_pixel; i++)
			{
				coefficient_group[i] *= (float)(filter_scale);
			}

			for (i = (int)(in_last_pixel - in_first_pixel); (i) >= (0); i--)
			{
				if ((coefficient_group[i]) != 0)
					break;
				contributor->n1 = (int)(contributor->n0 + i - 1);
			}
		}

		public static void stbir__calculate_coefficients_downsample(stbir__info stbir_info, int filter,
			float scale_ratio,
			int out_first_pixel, int out_last_pixel, float out_center_of_in, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			contributor->n0 = (int)(out_first_pixel);
			contributor->n1 = (int)(out_last_pixel);
			for (i = (int)(0); i <= out_last_pixel - out_first_pixel; i++)
			{
				float out_pixel_center = (float)((float)(i + out_first_pixel) + 0.5f);
				float x = (float)(out_pixel_center - out_center_of_in);
				coefficient_group[i] =
					(float)(stbir__filter_info_table[filter].kernel((float)(x), (float)(scale_ratio)) * scale_ratio);
			}

			for (i = (int)(out_last_pixel - out_first_pixel); (i) >= (0); i--)
			{
				if ((coefficient_group[i]) != 0)
					break;
				contributor->n1 = (int)(contributor->n0 + i - 1);
			}
		}

		public static void stbir__normalize_downsample_coefficients(stbir__info stbir_info,
			stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int num_contributors =
				(int)(stbir__get_contributors((float)(scale_ratio), (int)(filter), (int)(input_size),
					(int)(output_size)));
			int num_coefficients = (int)(stbir__get_coefficient_width((int)(filter), (float)(scale_ratio)));
			int i;
			int j;
			int skip;
			for (i = (int)(0); (i) < (output_size); i++)
			{
				float scale;
				float total = (float)(0);
				for (j = (int)(0); (j) < (num_contributors); j++)
				{
					if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
					{
						float coefficient =
							(float)
							(*
								stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(j),
									(int)(i - contributors[j].n0)));
						total += (float)(coefficient);
					}
					else if ((i) < (contributors[j].n0))
						break;
				}

				scale = (float)(1 / total);
				for (j = (int)(0); (j) < (num_contributors); j++)
				{
					if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
						*
							stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(j),
								(int)(i - contributors[j].n0)) *= (float)(scale);
					else if ((i) < (contributors[j].n0))
						break;
				}
			}

			for (j = (int)(0); (j) < (num_contributors); j++)
			{
				int range;
				int max;
				int width;
				skip = (int)(0);
				while ((*stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(j),
						   (int)(skip))) ==
					   (0))
				{
					skip++;
				}

				contributors[j].n0 += (int)(skip);
				while ((contributors[j].n0) < (0))
				{
					contributors[j].n0++;
					skip++;
				}

				range = (int)(contributors[j].n1 - contributors[j].n0 + 1);
				max = (int)(stbir__min((int)(num_coefficients), (int)(range)));
				width = (int)(stbir__get_coefficient_width((int)(filter), (float)(scale_ratio)));
				for (i = (int)(0); (i) < (max); i++)
				{
					if ((i + skip) >= (width))
						break;
					*stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(j), (int)(i)) =
						(float)
						(*stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(j),
							(int)(i + skip)));
				}

				continue;
			}

			for (i = (int)(0); (i) < (num_contributors); i++)
			{
				contributors[i].n1 = (int)(stbir__min((int)(contributors[i].n1), (int)(output_size - 1)));
			}
		}

		public static void stbir__calculate_filters(stbir__info stbir_info, stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int n;
			int total_contributors =
				(int)(stbir__get_contributors((float)(scale_ratio), (int)(filter), (int)(input_size),
					(int)(output_size)));
			if ((stbir__use_upsampling((float)(scale_ratio))) != 0)
			{
				float out_pixels_radius =
					(float)(stbir__filter_info_table[filter].support((float)(1 / scale_ratio)) * scale_ratio);
				for (n = (int)(0); (n) < (total_contributors); n++)
				{
					float in_center_of_out;
					int in_first_pixel;
					int in_last_pixel;
					stbir__calculate_sample_range_upsample((int)(n), (float)(out_pixels_radius),
						(float)(scale_ratio),
						(float)(shift), &in_first_pixel, &in_last_pixel, &in_center_of_out);
					stbir__calculate_coefficients_upsample(stbir_info, (int)(filter), (float)(scale_ratio),
						(int)(in_first_pixel),
						(int)(in_last_pixel), (float)(in_center_of_out),
						stbir__get_contributor(contributors, (int)(n)),
						stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(n),
							(int)(0)));
				}
			}
			else
			{
				float in_pixels_radius =
					(float)(stbir__filter_info_table[filter].support((float)(scale_ratio)) / scale_ratio);
				for (n = (int)(0); (n) < (total_contributors); n++)
				{
					float out_center_of_in;
					int out_first_pixel;
					int out_last_pixel;
					int n_adjusted = (int)(n - stbir__get_filter_pixel_margin((int)(filter), (float)(scale_ratio)));
					stbir__calculate_sample_range_downsample((int)(n_adjusted), (float)(in_pixels_radius),
						(float)(scale_ratio),
						(float)(shift), &out_first_pixel, &out_last_pixel, &out_center_of_in);
					stbir__calculate_coefficients_downsample(stbir_info, (int)(filter), (float)(scale_ratio),
						(int)(out_first_pixel),
						(int)(out_last_pixel), (float)(out_center_of_in),
						stbir__get_contributor(contributors, (int)(n)),
						stbir__get_coefficient(coefficients, (int)(filter), (float)(scale_ratio), (int)(n),
							(int)(0)));
				}

				stbir__normalize_downsample_coefficients(stbir_info, contributors, coefficients, (int)(filter),
					(float)(scale_ratio), (float)(shift), (int)(input_size), (int)(output_size));
			}

		}

		public static float* stbir__get_decode_buffer(stbir__info stbir_info)
		{
			return &stbir_info.decode_buffer[stbir_info.horizontal_filter_pixel_margin * stbir_info.channels];
		}

		public static void stbir__decode_scanline(stbir__info stbir_info, int n)
		{
			int c;
			int channels = (int)(stbir_info.channels);
			int alpha_channel = (int)(stbir_info.alpha_channel);
			int type = (int)(stbir_info.type);
			int colorspace = (int)(stbir_info.colorspace);
			int input_w = (int)(stbir_info.input_w);
			ulong input_stride_bytes = (ulong)(stbir_info.input_stride_bytes);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			int edge_horizontal = (int)(stbir_info.edge_horizontal);
			int edge_vertical = (int)(stbir_info.edge_vertical);
			ulong in_buffer_row_offset =
				(ulong)(stbir__edge_wrap((int)(edge_vertical), (int)(n), (int)(stbir_info.input_h)) *
						 (int)input_stride_bytes);
			void* input_data = (sbyte*)(stbir_info.input_data) + in_buffer_row_offset;
			int max_x = (int)(input_w + stbir_info.horizontal_filter_pixel_margin);
			int decode = (int)((type) * (STBIR_MAX_COLORSPACES) + (colorspace));
			int x = (int)(-stbir_info.horizontal_filter_pixel_margin);
			if (((edge_vertical) == (STBIR_EDGE_ZERO)) && (((n) < (0)) || ((n) >= (stbir_info.input_h))))
			{
				for (; (x) < (max_x); x++)
				{
					for (c = (int)(0); (c) < (channels); c++)
					{
						decode_buffer[x * channels + c] = (float)(0);
					}
				}

				return;
			}

			switch (decode)
			{
				case ((STBIR_TYPE_UINT8) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(((float)(((byte*)(input_data))[input_pixel_index + c])) / 255);
						}
					}

					break;
				case ((STBIR_TYPE_UINT8) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(stbir__srgb_uchar_to_linear_float[
									((byte*)(input_data))[input_pixel_index + c]]);
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float)(((float)(((byte*)(input_data))[input_pixel_index + alpha_channel])) / 255);
					}

					break;
				case ((STBIR_TYPE_UINT16) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(((float)(((ushort*)(input_data))[input_pixel_index + c])) / 65535);
						}
					}

					break;
				case ((STBIR_TYPE_UINT16) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(stbir__srgb_to_linear(
									(float)(((float)(((ushort*)(input_data))[input_pixel_index + c])) / 65535)));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float)(((float)(((ushort*)(input_data))[input_pixel_index + alpha_channel])) /
										 65535);
					}

					break;
				case ((STBIR_TYPE_UINT32) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								((float)(((double)(((uint*)(input_data))[input_pixel_index + c])) / 4294967295));
						}
					}

					break;
				case ((STBIR_TYPE_UINT32) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(stbir__srgb_to_linear(
									(float)(((double)(((uint*)(input_data))[input_pixel_index + c])) / 4294967295)));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								((float)(((double)(((uint*)(input_data))[input_pixel_index + alpha_channel])) /
										  4294967295));
					}

					break;
				case ((STBIR_TYPE_FLOAT) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(((float*)(input_data))[input_pixel_index + c]);
						}
					}

					break;
				case ((STBIR_TYPE_FLOAT) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						int decode_pixel_index = (int)(x * channels);
						int input_pixel_index =
							(int)(stbir__edge_wrap((int)(edge_horizontal), (int)(x), (int)(input_w)) * channels);
						for (c = (int)(0); (c) < (channels); c++)
						{
							decode_buffer[decode_pixel_index + c] =
								(float)(stbir__srgb_to_linear((float)(((float*)(input_data))[input_pixel_index + c]))
								);
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float)(((float*)(input_data))[input_pixel_index + alpha_channel]);
					}

					break;
				default:
					;
					break;
			}

			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int)(-stbir_info.horizontal_filter_pixel_margin); (x) < (max_x); x++)
				{
					int decode_pixel_index = (int)(x * channels);
					float alpha = (float)(decode_buffer[decode_pixel_index + alpha_channel]);
					if (stbir_info.type != STBIR_TYPE_FLOAT)
					{
						alpha += (float)((float)(1) / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20));
						decode_buffer[decode_pixel_index + alpha_channel] = (float)(alpha);
					}

					for (c = (int)(0); (c) < (channels); c++)
					{
						if ((c) == (alpha_channel))
							continue;
						decode_buffer[decode_pixel_index + c] *= (float)(alpha);
					}
				}
			}

			if ((edge_horizontal) == (STBIR_EDGE_ZERO))
			{
				for (x = (int)(-stbir_info.horizontal_filter_pixel_margin); (x) < (0); x++)
				{
					for (c = (int)(0); (c) < (channels); c++)
					{
						decode_buffer[x * channels + c] = (float)(0);
					}
				}

				for (x = (int)(input_w); (x) < (max_x); x++)
				{
					for (c = (int)(0); (c) < (channels); c++)
					{
						decode_buffer[x * channels + c] = (float)(0);
					}
				}
			}

		}

		public static float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)
		{
			return &ring_buffer[index * ring_buffer_length];
		}

		public static float* stbir__add_empty_ring_buffer_entry(stbir__info stbir_info, int n)
		{
			int ring_buffer_index;
			float* ring_buffer;
			stbir_info.ring_buffer_last_scanline = (int)(n);
			if ((stbir_info.ring_buffer_begin_index) < (0))
			{
				ring_buffer_index = (int)(stbir_info.ring_buffer_begin_index = (int)(0));
				stbir_info.ring_buffer_first_scanline = (int)(n);
			}
			else
			{
				ring_buffer_index =
					(int)
					((stbir_info.ring_buffer_begin_index +
					  (stbir_info.ring_buffer_last_scanline - stbir_info.ring_buffer_first_scanline)) %
					 stbir_info.ring_buffer_num_entries);
			}

			ring_buffer = stbir__get_ring_buffer_entry(stbir_info.ring_buffer, (int)(ring_buffer_index),
				(int)(stbir_info.ring_buffer_length_bytes / sizeof(float)));
			CRuntime.memset(ring_buffer, (int)(0), (ulong)(stbir_info.ring_buffer_length_bytes));
			return ring_buffer;
		}

		public static void stbir__resample_horizontal_upsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int output_w = (int)(stbir_info.output_w);
			int kernel_pixel_width = (int)(stbir_info.horizontal_filter_pixel_width);
			int channels = (int)(stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int)(stbir_info.horizontal_coefficient_width);
			for (x = (int)(0); (x) < (output_w); x++)
			{
				int n0 = (int)(horizontal_contributors[x].n0);
				int n1 = (int)(horizontal_contributors[x].n1);
				int out_pixel_index = (int)(x * channels);
				int coefficient_group = (int)(coefficient_width * x);
				int coefficient_counter = (int)(0);
				switch (channels)
				{
					case 1:
						for (k = (int)(n0); k <= n1; k++)
						{
							int in_pixel_index = (int)(k * 1);
							float coefficient =
								(float)(horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
						}

						break;
					case 2:
						for (k = (int)(n0); k <= n1; k++)
						{
							int in_pixel_index = (int)(k * 2);
							float coefficient =
								(float)(horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
						}

						break;
					case 3:
						for (k = (int)(n0); k <= n1; k++)
						{
							int in_pixel_index = (int)(k * 3);
							float coefficient =
								(float)(horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
							output_buffer[out_pixel_index + 2] +=
								(float)(decode_buffer[in_pixel_index + 2] * coefficient);
						}

						break;
					case 4:
						for (k = (int)(n0); k <= n1; k++)
						{
							int in_pixel_index = (int)(k * 4);
							float coefficient =
								(float)(horizontal_coefficients[coefficient_group + coefficient_counter++]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
							output_buffer[out_pixel_index + 2] +=
								(float)(decode_buffer[in_pixel_index + 2] * coefficient);
							output_buffer[out_pixel_index + 3] +=
								(float)(decode_buffer[in_pixel_index + 3] * coefficient);
						}

						break;
					default:
						for (k = (int)(n0); k <= n1; k++)
						{
							int in_pixel_index = (int)(k * channels);
							float coefficient =
								(float)(horizontal_coefficients[coefficient_group + coefficient_counter++]);
							int c;
							for (c = (int)(0); (c) < (channels); c++)
							{
								output_buffer[out_pixel_index + c] +=
									(float)(decode_buffer[in_pixel_index + c] * coefficient);
							}
						}

						break;
				}
			}
		}

		public static void stbir__resample_horizontal_downsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int input_w = (int)(stbir_info.input_w);
			int output_w = (int)(stbir_info.output_w);
			int kernel_pixel_width = (int)(stbir_info.horizontal_filter_pixel_width);
			int channels = (int)(stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int)(stbir_info.horizontal_coefficient_width);
			int filter_pixel_margin = (int)(stbir_info.horizontal_filter_pixel_margin);
			int max_x = (int)(input_w + filter_pixel_margin * 2);
			switch (channels)
			{
				case 1:
					for (x = (int)(0); (x) < (max_x); x++)
					{
						int n0 = (int)(horizontal_contributors[x].n0);
						int n1 = (int)(horizontal_contributors[x].n1);
						int in_x = (int)(x - filter_pixel_margin);
						int in_pixel_index = (int)(in_x * 1);
						int max_n = (int)(n1);
						int coefficient_group = (int)(coefficient_width * x);
						for (k = (int)(n0); k <= max_n; k++)
						{
							int out_pixel_index = (int)(k * 1);
							float coefficient = (float)(horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
						}
					}

					break;
				case 2:
					for (x = (int)(0); (x) < (max_x); x++)
					{
						int n0 = (int)(horizontal_contributors[x].n0);
						int n1 = (int)(horizontal_contributors[x].n1);
						int in_x = (int)(x - filter_pixel_margin);
						int in_pixel_index = (int)(in_x * 2);
						int max_n = (int)(n1);
						int coefficient_group = (int)(coefficient_width * x);
						for (k = (int)(n0); k <= max_n; k++)
						{
							int out_pixel_index = (int)(k * 2);
							float coefficient = (float)(horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
						}
					}

					break;
				case 3:
					for (x = (int)(0); (x) < (max_x); x++)
					{
						int n0 = (int)(horizontal_contributors[x].n0);
						int n1 = (int)(horizontal_contributors[x].n1);
						int in_x = (int)(x - filter_pixel_margin);
						int in_pixel_index = (int)(in_x * 3);
						int max_n = (int)(n1);
						int coefficient_group = (int)(coefficient_width * x);
						for (k = (int)(n0); k <= max_n; k++)
						{
							int out_pixel_index = (int)(k * 3);
							float coefficient = (float)(horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
							output_buffer[out_pixel_index + 2] +=
								(float)(decode_buffer[in_pixel_index + 2] * coefficient);
						}
					}

					break;
				case 4:
					for (x = (int)(0); (x) < (max_x); x++)
					{
						int n0 = (int)(horizontal_contributors[x].n0);
						int n1 = (int)(horizontal_contributors[x].n1);
						int in_x = (int)(x - filter_pixel_margin);
						int in_pixel_index = (int)(in_x * 4);
						int max_n = (int)(n1);
						int coefficient_group = (int)(coefficient_width * x);
						for (k = (int)(n0); k <= max_n; k++)
						{
							int out_pixel_index = (int)(k * 4);
							float coefficient = (float)(horizontal_coefficients[coefficient_group + k - n0]);
							output_buffer[out_pixel_index + 0] +=
								(float)(decode_buffer[in_pixel_index + 0] * coefficient);
							output_buffer[out_pixel_index + 1] +=
								(float)(decode_buffer[in_pixel_index + 1] * coefficient);
							output_buffer[out_pixel_index + 2] +=
								(float)(decode_buffer[in_pixel_index + 2] * coefficient);
							output_buffer[out_pixel_index + 3] +=
								(float)(decode_buffer[in_pixel_index + 3] * coefficient);
						}
					}

					break;
				default:
					for (x = (int)(0); (x) < (max_x); x++)
					{
						int n0 = (int)(horizontal_contributors[x].n0);
						int n1 = (int)(horizontal_contributors[x].n1);
						int in_x = (int)(x - filter_pixel_margin);
						int in_pixel_index = (int)(in_x * channels);
						int max_n = (int)(n1);
						int coefficient_group = (int)(coefficient_width * x);
						for (k = (int)(n0); k <= max_n; k++)
						{
							int c;
							int out_pixel_index = (int)(k * channels);
							float coefficient = (float)(horizontal_coefficients[coefficient_group + k - n0]);
							for (c = (int)(0); (c) < (channels); c++)
							{
								output_buffer[out_pixel_index + c] +=
									(float)(decode_buffer[in_pixel_index + c] * coefficient);
							}
						}
					}

					break;
			}

		}

		public static void stbir__decode_and_resample_upsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int)(n));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int)(n),
					stbir__add_empty_ring_buffer_entry(stbir_info, (int)(n)));
			else
				stbir__resample_horizontal_downsample(stbir_info, (int)(n),
					stbir__add_empty_ring_buffer_entry(stbir_info, (int)(n)));
		}

		public static void stbir__decode_and_resample_downsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int)(n));
			CRuntime.memset(stbir_info.horizontal_buffer, (int)(0),
				(ulong)(stbir_info.output_w * stbir_info.channels * sizeof(float)));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int)(n), stbir_info.horizontal_buffer);
			else
				stbir__resample_horizontal_downsample(stbir_info, (int)(n), stbir_info.horizontal_buffer);
		}

		public static float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index,
			int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
		{
			int ring_buffer_index = (int)((begin_index + (get_scanline - first_scanline)) % ring_buffer_num_entries);
			return stbir__get_ring_buffer_entry(ring_buffer, (int)(ring_buffer_index), (int)(ring_buffer_length));
		}

		public static void stbir__encode_scanline(stbir__info stbir_info, int num_pixels, void* output_buffer,
			float* encode_buffer, int channels, int alpha_channel, int decode)
		{
			int x;
			int n;
			int num_nonalpha;
			ushort* nonalpha = stackalloc ushort[64];
			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int)(0); (x) < (num_pixels); ++x)
				{
					int pixel_index = (int)(x * channels);
					float alpha = (float)(encode_buffer[pixel_index + alpha_channel]);
					float reciprocal_alpha = (float)((alpha) != 0 ? 1.0f / alpha : 0);
					for (n = (int)(0); (n) < (channels); n++)
					{
						if (n != alpha_channel)
							encode_buffer[pixel_index + n] *= (float)(reciprocal_alpha);
					}
				}
			}

			for (x = (int)(0), num_nonalpha = (int)(0); (x) < (channels); ++x)
			{
				if ((x != alpha_channel) || ((stbir_info.flags & (1 << 1)) != 0))
					nonalpha[num_nonalpha++] = (ushort)(x);
			}

			switch (decode)
			{
				case ((STBIR_TYPE_UINT8) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (channels); n++)
						{
							int index = (int)(pixel_index + n);
							((byte*)(output_buffer))[index] =
								((byte)((int)((stbir__saturate((float)(encode_buffer[index])) * 255) + 0.5)));
						}
					}

					break;
				case ((STBIR_TYPE_UINT8) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (num_nonalpha); n++)
						{
							int index = (int)(pixel_index + nonalpha[n]);
							((byte*)(output_buffer))[index] =
								(byte)(stbir__linear_to_srgb_uchar((float)(encode_buffer[index])));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							((byte*)(output_buffer))[pixel_index + alpha_channel] =
								((byte)((int)((stbir__saturate((float)(encode_buffer[pixel_index + alpha_channel])) *
												 255) + 0.5)));
					}

					break;
				case ((STBIR_TYPE_UINT16) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (channels); n++)
						{
							int index = (int)(pixel_index + n);
							((ushort*)(output_buffer))[index] =
								((ushort)((int)((stbir__saturate((float)(encode_buffer[index])) * 65535) + 0.5)));
						}
					}

					break;
				case ((STBIR_TYPE_UINT16) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (num_nonalpha); n++)
						{
							int index = (int)(pixel_index + nonalpha[n]);
							((ushort*)(output_buffer))[index] =
								((ushort)
									((int)((stbir__linear_to_srgb(
												 (float)(stbir__saturate((float)(encode_buffer[index])))) * 65535) +
											0.5)));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							((ushort*)(output_buffer))[pixel_index + alpha_channel] =
								((ushort)((int)(
									(stbir__saturate((float)(encode_buffer[pixel_index + alpha_channel])) * 65535) +
									0.5)));
					}

					break;
				case ((STBIR_TYPE_UINT32) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (channels); n++)
						{
							int index = (int)(pixel_index + n);
							((uint*)(output_buffer))[index] =
								((uint)((((double)(stbir__saturate((float)(encode_buffer[index])))) * 4294967295) +
										 0.5));
						}
					}

					break;
				case ((STBIR_TYPE_UINT32) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (num_nonalpha); n++)
						{
							int index = (int)(pixel_index + nonalpha[n]);
							((uint*)(output_buffer))[index] =
								((uint)
									((((double)(stbir__linear_to_srgb(
										  (float)(stbir__saturate((float)(encode_buffer[index])))))) * 4294967295) +
									 0.5));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							((uint*)(output_buffer))[pixel_index + alpha_channel] =
								((uint)
									((int)((((double)(stbir__saturate(
												 (float)(encode_buffer[pixel_index + alpha_channel])))) * 4294967295) +
											0.5)));
					}

					break;
				case ((STBIR_TYPE_FLOAT) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (channels); n++)
						{
							int index = (int)(pixel_index + n);
							((float*)(output_buffer))[index] = (float)(encode_buffer[index]);
						}
					}

					break;
				case ((STBIR_TYPE_FLOAT) * (STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int)(0); (x) < (num_pixels); ++x)
					{
						int pixel_index = (int)(x * channels);
						for (n = (int)(0); (n) < (num_nonalpha); n++)
						{
							int index = (int)(pixel_index + nonalpha[n]);
							((float*)(output_buffer))[index] =
								(float)(stbir__linear_to_srgb((float)(encode_buffer[index])));
						}

						if ((stbir_info.flags & (1 << 1)) == 0)
							((float*)(output_buffer))[pixel_index + alpha_channel] =
								(float)(encode_buffer[pixel_index + alpha_channel]);
					}

					break;
				default:
					;
					break;
			}

		}

		public static void stbir__resample_vertical_upsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int)(stbir_info.output_w);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int)(stbir_info.channels);
			int alpha_channel = (int)(stbir_info.alpha_channel);
			int type = (int)(stbir_info.type);
			int colorspace = (int)(stbir_info.colorspace);
			int ring_buffer_entries = (int)(stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* encode_buffer = stbir_info.encode_buffer;
			int decode = (int)((type) * (STBIR_MAX_COLORSPACES) + (colorspace));
			int coefficient_width = (int)(stbir_info.vertical_coefficient_width);
			int coefficient_counter;
			int contributor = (int)(n);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int)(stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int)(stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int)(stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int)(stbir_info.ring_buffer_length_bytes / sizeof(float));
			int n0;
			int n1;
			int output_row_start;
			int coefficient_group = (int)(coefficient_width * contributor);
			n0 = (int)(vertical_contributors[contributor].n0);
			n1 = (int)(vertical_contributors[contributor].n1);
			output_row_start = (int)(n * stbir_info.output_stride_bytes);
			CRuntime.memset(encode_buffer, (int)(0), (ulong)(output_w * sizeof(float) * channels));
			coefficient_counter = (int)(0);
			switch (channels)
			{
				case 1:
					for (k = (int)(n0); k <= n1; k++)
					{
						int coefficient_index = (int)(coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
							(int)(ring_buffer_begin_index),
							(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries),
							(int)(ring_buffer_length));
						float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int)(0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int)(x * 1);
							encode_buffer[in_pixel_index + 0] +=
								(float)(ring_buffer_entry[in_pixel_index + 0] * coefficient);
						}
					}

					break;
				case 2:
					for (k = (int)(n0); k <= n1; k++)
					{
						int coefficient_index = (int)(coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
							(int)(ring_buffer_begin_index),
							(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries),
							(int)(ring_buffer_length));
						float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int)(0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int)(x * 2);
							encode_buffer[in_pixel_index + 0] +=
								(float)(ring_buffer_entry[in_pixel_index + 0] * coefficient);
							encode_buffer[in_pixel_index + 1] +=
								(float)(ring_buffer_entry[in_pixel_index + 1] * coefficient);
						}
					}

					break;
				case 3:
					for (k = (int)(n0); k <= n1; k++)
					{
						int coefficient_index = (int)(coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
							(int)(ring_buffer_begin_index),
							(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries),
							(int)(ring_buffer_length));
						float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int)(0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int)(x * 3);
							encode_buffer[in_pixel_index + 0] +=
								(float)(ring_buffer_entry[in_pixel_index + 0] * coefficient);
							encode_buffer[in_pixel_index + 1] +=
								(float)(ring_buffer_entry[in_pixel_index + 1] * coefficient);
							encode_buffer[in_pixel_index + 2] +=
								(float)(ring_buffer_entry[in_pixel_index + 2] * coefficient);
						}
					}

					break;
				case 4:
					for (k = (int)(n0); k <= n1; k++)
					{
						int coefficient_index = (int)(coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
							(int)(ring_buffer_begin_index),
							(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries),
							(int)(ring_buffer_length));
						float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int)(0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int)(x * 4);
							encode_buffer[in_pixel_index + 0] +=
								(float)(ring_buffer_entry[in_pixel_index + 0] * coefficient);
							encode_buffer[in_pixel_index + 1] +=
								(float)(ring_buffer_entry[in_pixel_index + 1] * coefficient);
							encode_buffer[in_pixel_index + 2] +=
								(float)(ring_buffer_entry[in_pixel_index + 2] * coefficient);
							encode_buffer[in_pixel_index + 3] +=
								(float)(ring_buffer_entry[in_pixel_index + 3] * coefficient);
						}
					}

					break;
				default:
					for (k = (int)(n0); k <= n1; k++)
					{
						int coefficient_index = (int)(coefficient_counter++);
						float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
							(int)(ring_buffer_begin_index),
							(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries),
							(int)(ring_buffer_length));
						float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
						for (x = (int)(0); (x) < (output_w); ++x)
						{
							int in_pixel_index = (int)(x * channels);
							int c;
							for (c = (int)(0); (c) < (channels); c++)
							{
								encode_buffer[in_pixel_index + c] +=
									(float)(ring_buffer_entry[in_pixel_index + c] * coefficient);
							}
						}
					}

					break;
			}

			stbir__encode_scanline(stbir_info, (int)(output_w), (sbyte*)(output_data) + output_row_start,
				encode_buffer,
				(int)(channels), (int)(alpha_channel), (int)(decode));
		}

		public static void stbir__resample_vertical_downsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int)(stbir_info.output_w);
			int output_h = (int)(stbir_info.output_h);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int)(stbir_info.channels);
			int ring_buffer_entries = (int)(stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* horizontal_buffer = stbir_info.horizontal_buffer;
			int coefficient_width = (int)(stbir_info.vertical_coefficient_width);
			int contributor = (int)(n + stbir_info.vertical_filter_pixel_margin);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int)(stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int)(stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int)(stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int)(stbir_info.ring_buffer_length_bytes / sizeof(float));
			int n0;
			int n1;
			n0 = (int)(vertical_contributors[contributor].n0);
			n1 = (int)(vertical_contributors[contributor].n1);
			for (k = (int)(n0); k <= n1; k++)
			{
				int coefficient_index = (int)(k - n0);
				int coefficient_group = (int)(coefficient_width * contributor);
				float coefficient = (float)(vertical_coefficients[coefficient_group + coefficient_index]);
				float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int)(k), ring_buffer,
					(int)(ring_buffer_begin_index),
					(int)(ring_buffer_first_scanline), (int)(ring_buffer_entries), (int)(ring_buffer_length));
				switch (channels)
				{
					case 1:
						for (x = (int)(0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int)(x * 1);
							ring_buffer_entry[in_pixel_index + 0] +=
								(float)(horizontal_buffer[in_pixel_index + 0] * coefficient);
						}

						break;
					case 2:
						for (x = (int)(0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int)(x * 2);
							ring_buffer_entry[in_pixel_index + 0] +=
								(float)(horizontal_buffer[in_pixel_index + 0] * coefficient);
							ring_buffer_entry[in_pixel_index + 1] +=
								(float)(horizontal_buffer[in_pixel_index + 1] * coefficient);
						}

						break;
					case 3:
						for (x = (int)(0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int)(x * 3);
							ring_buffer_entry[in_pixel_index + 0] +=
								(float)(horizontal_buffer[in_pixel_index + 0] * coefficient);
							ring_buffer_entry[in_pixel_index + 1] +=
								(float)(horizontal_buffer[in_pixel_index + 1] * coefficient);
							ring_buffer_entry[in_pixel_index + 2] +=
								(float)(horizontal_buffer[in_pixel_index + 2] * coefficient);
						}

						break;
					case 4:
						for (x = (int)(0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int)(x * 4);
							ring_buffer_entry[in_pixel_index + 0] +=
								(float)(horizontal_buffer[in_pixel_index + 0] * coefficient);
							ring_buffer_entry[in_pixel_index + 1] +=
								(float)(horizontal_buffer[in_pixel_index + 1] * coefficient);
							ring_buffer_entry[in_pixel_index + 2] +=
								(float)(horizontal_buffer[in_pixel_index + 2] * coefficient);
							ring_buffer_entry[in_pixel_index + 3] +=
								(float)(horizontal_buffer[in_pixel_index + 3] * coefficient);
						}

						break;
					default:
						for (x = (int)(0); (x) < (output_w); x++)
						{
							int in_pixel_index = (int)(x * channels);
							int c;
							for (c = (int)(0); (c) < (channels); c++)
							{
								ring_buffer_entry[in_pixel_index + c] +=
									(float)(horizontal_buffer[in_pixel_index + c] * coefficient);
							}
						}

						break;
				}
			}
		}

		public static void stbir__buffer_loop_upsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float)(stbir_info.vertical_scale);
			float out_scanlines_radius =
				(float)(stbir__filter_info_table[stbir_info.vertical_filter].support((float)(1 / scale_ratio)) *
						 scale_ratio);
			for (y = (int)(0); (y) < (stbir_info.output_h); y++)
			{
				float in_center_of_out = (float)(0);
				int in_first_scanline = (int)(0);
				int in_last_scanline = (int)(0);
				stbir__calculate_sample_range_upsample((int)(y), (float)(out_scanlines_radius), (float)(scale_ratio),
					(float)(stbir_info.vertical_shift), &in_first_scanline, &in_last_scanline, &in_center_of_out);
				if ((stbir_info.ring_buffer_begin_index) >= (0))
				{
					while ((in_first_scanline) > (stbir_info.ring_buffer_first_scanline))
					{
						if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
						{
							stbir_info.ring_buffer_begin_index = (int)(-1);
							stbir_info.ring_buffer_first_scanline = (int)(0);
							stbir_info.ring_buffer_last_scanline = (int)(0);
							break;
						}
						else
						{
							stbir_info.ring_buffer_first_scanline++;
							stbir_info.ring_buffer_begin_index =
								(int)((stbir_info.ring_buffer_begin_index + 1) % stbir_info.ring_buffer_num_entries);
						}
					}
				}

				if ((stbir_info.ring_buffer_begin_index) < (0))
					stbir__decode_and_resample_upsample(stbir_info, (int)(in_first_scanline));
				while ((in_last_scanline) > (stbir_info.ring_buffer_last_scanline))
				{
					stbir__decode_and_resample_upsample(stbir_info, (int)(stbir_info.ring_buffer_last_scanline + 1));
				}

				stbir__resample_vertical_upsample(stbir_info, (int)(y), (int)(in_first_scanline),
					(int)(in_last_scanline),
					(float)(in_center_of_out));
			}
		}

		public static void stbir__empty_ring_buffer(stbir__info stbir_info, int first_necessary_scanline)
		{
			int output_stride_bytes = (int)(stbir_info.output_stride_bytes);
			int channels = (int)(stbir_info.channels);
			int alpha_channel = (int)(stbir_info.alpha_channel);
			int type = (int)(stbir_info.type);
			int colorspace = (int)(stbir_info.colorspace);
			int output_w = (int)(stbir_info.output_w);
			void* output_data = stbir_info.output_data;
			int decode = (int)((type) * (STBIR_MAX_COLORSPACES) + (colorspace));
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_length = (int)(stbir_info.ring_buffer_length_bytes / sizeof(float));
			if ((stbir_info.ring_buffer_begin_index) >= (0))
			{
				while ((first_necessary_scanline) > (stbir_info.ring_buffer_first_scanline))
				{
					if (((stbir_info.ring_buffer_first_scanline) >= (0)) &&
						((stbir_info.ring_buffer_first_scanline) < (stbir_info.output_h)))
					{
						int output_row_start = (int)(stbir_info.ring_buffer_first_scanline * output_stride_bytes);
						float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer,
							(int)(stbir_info.ring_buffer_begin_index),
							(int)(ring_buffer_length));
						stbir__encode_scanline(stbir_info, (int)(output_w), (sbyte*)(output_data) + output_row_start,
							ring_buffer_entry,
							(int)(channels), (int)(alpha_channel), (int)(decode));
					}

					if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
					{
						stbir_info.ring_buffer_begin_index = (int)(-1);
						stbir_info.ring_buffer_first_scanline = (int)(0);
						stbir_info.ring_buffer_last_scanline = (int)(0);
						break;
					}
					else
					{
						stbir_info.ring_buffer_first_scanline++;
						stbir_info.ring_buffer_begin_index =
							(int)((stbir_info.ring_buffer_begin_index + 1) % stbir_info.ring_buffer_num_entries);
					}
				}
			}

		}

		public static void stbir__buffer_loop_downsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float)(stbir_info.vertical_scale);
			int output_h = (int)(stbir_info.output_h);
			float in_pixels_radius =
				(float)(stbir__filter_info_table[stbir_info.vertical_filter].support((float)(scale_ratio)) /
						 scale_ratio);
			int pixel_margin = (int)(stbir_info.vertical_filter_pixel_margin);
			int max_y = (int)(stbir_info.input_h + pixel_margin);
			for (y = (int)(-pixel_margin); (y) < (max_y); y++)
			{
				float out_center_of_in;
				int out_first_scanline;
				int out_last_scanline;
				stbir__calculate_sample_range_downsample((int)(y), (float)(in_pixels_radius), (float)(scale_ratio),
					(float)(stbir_info.vertical_shift), &out_first_scanline, &out_last_scanline, &out_center_of_in);
				if (((out_last_scanline) < (0)) || ((out_first_scanline) >= (output_h)))
					continue;
				stbir__empty_ring_buffer(stbir_info, (int)(out_first_scanline));
				stbir__decode_and_resample_downsample(stbir_info, (int)(y));
				if ((stbir_info.ring_buffer_begin_index) < (0))
					stbir__add_empty_ring_buffer_entry(stbir_info, (int)(out_first_scanline));
				while ((out_last_scanline) > (stbir_info.ring_buffer_last_scanline))
				{
					stbir__add_empty_ring_buffer_entry(stbir_info, (int)(stbir_info.ring_buffer_last_scanline + 1));
				}

				stbir__resample_vertical_downsample(stbir_info, (int)(y), (int)(out_first_scanline),
					(int)(out_last_scanline),
					(float)(out_center_of_in));
			}

			stbir__empty_ring_buffer(stbir_info, (int)(stbir_info.output_h));
		}

		public static void stbir__setup(stbir__info info, int input_w, int input_h, int output_w, int output_h,
			int channels)
		{
			info.input_w = (int)(input_w);
			info.input_h = (int)(input_h);
			info.output_w = (int)(output_w);
			info.output_h = (int)(output_h);
			info.channels = (int)(channels);
		}

		public static void stbir__calculate_transform(stbir__info info, float s0, float t0, float s1, float t1,
			float* transform)
		{
			info.s0 = (float)(s0);
			info.t0 = (float)(t0);
			info.s1 = (float)(s1);
			info.t1 = (float)(t1);
			if ((transform) != null)
			{
				info.horizontal_scale = (float)(transform[0]);
				info.vertical_scale = (float)(transform[1]);
				info.horizontal_shift = (float)(transform[2]);
				info.vertical_shift = (float)(transform[3]);
			}
			else
			{
				info.horizontal_scale = (float)(((float)(info.output_w) / info.input_w) / (s1 - s0));
				info.vertical_scale = (float)(((float)(info.output_h) / info.input_h) / (t1 - t0));
				info.horizontal_shift = (float)(s0 * info.output_w / (s1 - s0));
				info.vertical_shift = (float)(t0 * info.output_h / (t1 - t0));
			}

		}

		public static void stbir__choose_filter(stbir__info info, int h_filter, int v_filter)
		{
			if ((h_filter) == (0))
				h_filter =
					(int)
					((stbir__use_upsampling((float)(info.horizontal_scale))) != 0
						? STBIR_FILTER_CATMULLROM
						: STBIR_FILTER_MITCHELL);
			if ((v_filter) == (0))
				v_filter =
					(int)
					((stbir__use_upsampling((float)(info.vertical_scale))) != 0
						? STBIR_FILTER_CATMULLROM
						: STBIR_FILTER_MITCHELL);
			info.horizontal_filter = (int)(h_filter);
			info.vertical_filter = (int)(v_filter);
		}

		public static uint stbir__calculate_memory(stbir__info info)
		{
			int pixel_margin =
				(int)(stbir__get_filter_pixel_margin((int)(info.horizontal_filter), (float)(info.horizontal_scale)));
			int filter_height =
				(int)(stbir__get_filter_pixel_width((int)(info.vertical_filter), (float)(info.vertical_scale)));
			info.horizontal_num_contributors =
				(int)
				(stbir__get_contributors((float)(info.horizontal_scale), (int)(info.horizontal_filter),
					(int)(info.input_w),
					(int)(info.output_w)));
			info.vertical_num_contributors =
				(int)
				(stbir__get_contributors((float)(info.vertical_scale), (int)(info.vertical_filter),
					(int)(info.input_h),
					(int)(info.output_h)));
			info.ring_buffer_num_entries = (int)(filter_height + 1);
			info.horizontal_contributors_size = (int)(info.horizontal_num_contributors * sizeof(stbir__contributors));
			info.horizontal_coefficients_size = (int)(stbir__get_total_horizontal_coefficients(info) * sizeof(float));
			info.vertical_contributors_size = (int)(info.vertical_num_contributors * sizeof(stbir__contributors));
			info.vertical_coefficients_size = (int)(stbir__get_total_vertical_coefficients(info) * sizeof(float));
			info.decode_buffer_size = (int)((info.input_w + pixel_margin * 2) * info.channels * sizeof(float));
			info.horizontal_buffer_size = (int)(info.output_w * info.channels * sizeof(float));
			info.ring_buffer_size =
				(int)(info.output_w * info.channels * info.ring_buffer_num_entries * sizeof(float));
			info.encode_buffer_size = (int)(info.output_w * info.channels * sizeof(float));
			if ((stbir__use_height_upsampling(info)) != 0)
				info.horizontal_buffer_size = (int)(0);
			else
				info.encode_buffer_size = (int)(0);
			return
				(uint)
				(info.horizontal_contributors_size + info.horizontal_coefficients_size +
				 info.vertical_contributors_size +
				 info.vertical_coefficients_size + info.decode_buffer_size + info.horizontal_buffer_size +
				 info.ring_buffer_size +
				 info.encode_buffer_size);
		}

		public static int stbir__resize_allocated(stbir__info info, void* input_data, int input_stride_in_bytes,
			void* output_data, int output_stride_in_bytes, int alpha_channel, uint flags, int type, int edge_horizontal,
			int edge_vertical, int colorspace, void* tempmem, ulong tempmem_size_in_bytes)
		{
			ulong memory_required = (ulong)(stbir__calculate_memory(info));
			int width_stride_input =
				(int)((input_stride_in_bytes) != 0
					? input_stride_in_bytes
					: info.channels * info.input_w * stbir__type_size[type]);
			int width_stride_output =
				(int)((output_stride_in_bytes) != 0
					? output_stride_in_bytes
					: info.channels * info.output_w * stbir__type_size[type]);
			if (((info.channels) < (0)) || ((info.channels) > (64)))
				return (int)(0);
			if ((info.horizontal_filter) >= (6))
				return (int)(0);
			if ((info.vertical_filter) >= (6))
				return (int)(0);
			if ((alpha_channel) < (0))
				flags |= (uint)((1 << 1) | (1 << 0));
			if (((flags & (1 << 1)) == 0) || ((flags & (1 << 0)) == 0))
				;
			if ((alpha_channel) >= (info.channels))
				return (int)(0);
			if (tempmem == null)
				return (int)(0);
			if ((tempmem_size_in_bytes) < (memory_required))
				return (int)(0);
			CRuntime.memset(tempmem, (int)(0), (ulong)(tempmem_size_in_bytes));
			info.input_data = input_data;
			info.input_stride_bytes = (int)(width_stride_input);
			info.output_data = output_data;
			info.output_stride_bytes = (int)(width_stride_output);
			info.alpha_channel = (int)(alpha_channel);
			info.flags = (uint)(flags);
			info.type = (int)(type);
			info.edge_horizontal = (int)(edge_horizontal);
			info.edge_vertical = (int)(edge_vertical);
			info.colorspace = (int)(colorspace);
			info.horizontal_coefficient_width =
				(int)(stbir__get_coefficient_width((int)(info.horizontal_filter), (float)(info.horizontal_scale)));
			info.vertical_coefficient_width =
				(int)(stbir__get_coefficient_width((int)(info.vertical_filter), (float)(info.vertical_scale)));
			info.horizontal_filter_pixel_width =
				(int)(stbir__get_filter_pixel_width((int)(info.horizontal_filter), (float)(info.horizontal_scale)));
			info.vertical_filter_pixel_width =
				(int)(stbir__get_filter_pixel_width((int)(info.vertical_filter), (float)(info.vertical_scale)));
			info.horizontal_filter_pixel_margin =
				(int)(stbir__get_filter_pixel_margin((int)(info.horizontal_filter), (float)(info.horizontal_scale)));
			info.vertical_filter_pixel_margin =
				(int)(stbir__get_filter_pixel_margin((int)(info.vertical_filter), (float)(info.vertical_scale)));
			info.ring_buffer_length_bytes = (int)(info.output_w * info.channels * sizeof(float));
			info.decode_buffer_pixels = (int)(info.input_w + info.horizontal_filter_pixel_margin * 2);
			info.horizontal_contributors = (stbir__contributors*)(tempmem);
			info.horizontal_coefficients =
				(float*)(((byte*)(info.horizontal_contributors)) + info.horizontal_contributors_size);
			info.vertical_contributors =
				(stbir__contributors*)(((byte*)(info.horizontal_coefficients)) + info.horizontal_coefficients_size);
			info.vertical_coefficients =
				(float*)(((byte*)(info.vertical_contributors)) + info.vertical_contributors_size);
			info.decode_buffer = (float*)(((byte*)(info.vertical_coefficients)) + info.vertical_coefficients_size);
			if ((stbir__use_height_upsampling(info)) != 0)
			{
				info.horizontal_buffer = null;
				info.ring_buffer = (float*)(((byte*)(info.decode_buffer)) + info.decode_buffer_size);
				info.encode_buffer = (float*)(((byte*)(info.ring_buffer)) + info.ring_buffer_size);
			}
			else
			{
				info.horizontal_buffer = (float*)(((byte*)(info.decode_buffer)) + info.decode_buffer_size);
				info.ring_buffer = (float*)(((byte*)(info.horizontal_buffer)) + info.horizontal_buffer_size);
				info.encode_buffer = null;
			}

			info.ring_buffer_begin_index = (int)(-1);
			stbir__calculate_filters(info, info.horizontal_contributors, info.horizontal_coefficients,
				(int)(info.horizontal_filter), (float)(info.horizontal_scale), (float)(info.horizontal_shift),
				(int)(info.input_w), (int)(info.output_w));
			stbir__calculate_filters(info, info.vertical_contributors, info.vertical_coefficients,
				(int)(info.vertical_filter),
				(float)(info.vertical_scale), (float)(info.vertical_shift), (int)(info.input_h),
				(int)(info.output_h));
			if ((stbir__use_height_upsampling(info)) != 0)
				stbir__buffer_loop_upsample(info);
			else
				stbir__buffer_loop_downsample(info);
			return (int)(1);
		}

		public static int stbir__resize_arbitrary(void* alloc_context, void* input_data, int input_w, int input_h,
			int input_stride_in_bytes, void* output_data, int output_w, int output_h, int output_stride_in_bytes,
			float s0,
			float t0, float s1, float t1, float* transform, int channels, int alpha_channel, uint flags, int type,
			int h_filter,
			int v_filter, int edge_horizontal, int edge_vertical, int colorspace)
		{
			stbir__info info = new stbir__info();
			int result;
			ulong memory_required;
			void* extra_memory;
			stbir__setup(info, (int)(input_w), (int)(input_h), (int)(output_w), (int)(output_h), (int)(channels));
			stbir__calculate_transform(info, (float)(s0), (float)(t0), (float)(s1), (float)(t1), transform);
			stbir__choose_filter(info, (int)(h_filter), (int)(v_filter));
			memory_required = (ulong)(stbir__calculate_memory(info));
			extra_memory = CRuntime.malloc((ulong)(memory_required));
			if (extra_memory == null)
				return (int)(0);
			result =
				(int)
				(stbir__resize_allocated(info, input_data, (int)(input_stride_in_bytes), output_data,
					(int)(output_stride_in_bytes), (int)(alpha_channel), (uint)(flags), (int)(type),
					(int)(edge_horizontal),
					(int)(edge_vertical), (int)(colorspace), extra_memory, (ulong)(memory_required)));
			CRuntime.free(extra_memory);
			return (int)(result);
		}

		public static int stbir_resize_uint8(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
				(stbir__resize_arbitrary(null, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes),
					output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes), (float)(0),
					(float)(0),
					(float)(1), (float)(1), null, (int)(num_channels), (int)(-1), (uint)(0),
					(int)(STBIR_TYPE_UINT8),
					(int)(STBIR_FILTER_DEFAULT), (int)(STBIR_FILTER_DEFAULT), (int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_float(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
				(stbir__resize_arbitrary(null, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes),
					output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes), (float)(0),
					(float)(0),
					(float)(1), (float)(1), null, (int)(num_channels), (int)(-1), (uint)(0),
					(int)(STBIR_TYPE_FLOAT),
					(int)(STBIR_FILTER_DEFAULT), (int)(STBIR_FILTER_DEFAULT), (int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_uint8_srgb(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels,
			int alpha_channel,
			int flags)
		{
			return
				(int)
				(stbir__resize_arbitrary(null, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes),
					output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes), (float)(0),
					(float)(0),
					(float)(1), (float)(1), null, (int)(num_channels), (int)(alpha_channel), (uint)(flags),
					(int)(STBIR_TYPE_UINT8),
					(int)(STBIR_FILTER_DEFAULT), (int)(STBIR_FILTER_DEFAULT), (int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_EDGE_CLAMP),
					(int)(STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_srgb_edgemode(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode)
		{
			return
				(int)
				(stbir__resize_arbitrary(null, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes),
					output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes), (float)(0),
					(float)(0),
					(float)(1), (float)(1), null, (int)(num_channels), (int)(alpha_channel), (uint)(flags),
					(int)(STBIR_TYPE_UINT8),
					(int)(STBIR_FILTER_DEFAULT), (int)(STBIR_FILTER_DEFAULT), (int)(edge_wrap_mode),
					(int)(edge_wrap_mode),
					(int)(STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_generic(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels,
			int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(0), (float)(0), (float)(1), (float)(1), null, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags),
					(int)(STBIR_TYPE_UINT8), (int)(filter), (int)(filter), (int)(edge_wrap_mode),
					(int)(edge_wrap_mode),
					(int)(space)));
		}

		public static int stbir_resize_uint16_generic(ushort* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, ushort* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space,
			void* alloc_context)
		{
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(0), (float)(0), (float)(1), (float)(1), null, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags),
					(int)(STBIR_TYPE_UINT16), (int)(filter), (int)(filter), (int)(edge_wrap_mode),
					(int)(edge_wrap_mode),
					(int)(space)));
		}

		public static int stbir_resize_float_generic(float* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels,
			int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(0), (float)(0), (float)(1), (float)(1), null, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags),
					(int)(STBIR_TYPE_FLOAT), (int)(filter), (int)(filter), (int)(edge_wrap_mode),
					(int)(edge_wrap_mode),
					(int)(space)));
		}

		public static int stbir_resize(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context)
		{
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(0), (float)(0), (float)(1), (float)(1), null, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags),
					(int)(datatype), (int)(filter_horizontal), (int)(filter_vertical), (int)(edge_mode_horizontal),
					(int)(edge_mode_vertical), (int)(space)));
		}

		public static int stbir_resize_subpixel(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float x_scale, float y_scale, float x_offset,
			float y_offset)
		{
			float* transform = stackalloc float[4];
			transform[0] = (float)(x_scale);
			transform[1] = (float)(y_scale);
			transform[2] = (float)(x_offset);
			transform[3] = (float)(y_offset);
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(0), (float)(0), (float)(1), (float)(1), transform, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags), (int)(datatype), (int)(filter_horizontal), (int)(filter_vertical),
					(int)(edge_mode_horizontal),
					(int)(edge_mode_vertical), (int)(space)));
		}

		public static int stbir_resize_region(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float s0, float t0, float s1, float t1)
		{
			return
				(int)
				(stbir__resize_arbitrary(alloc_context, input_pixels, (int)(input_w), (int)(input_h),
					(int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
					(int)(output_stride_in_bytes),
					(float)(s0), (float)(t0), (float)(s1), (float)(t1), null, (int)(num_channels),
					(int)(alpha_channel),
					(uint)(flags), (int)(datatype), (int)(filter_horizontal), (int)(filter_vertical),
					(int)(edge_mode_horizontal),
					(int)(edge_mode_vertical), (int)(space)));
		}
	}
}